# 2-2. レーザーコントローラーの実装  　　

![image][1073979556]

** 今回のサンプルシーンの場所 **
- git:// VR-studies/Asset/VR-studies/2_VR-controller/2-2_LaserController

今回は視線入力よりもよりピンポイントに対象を操作しやすいレーザーポインター型の入力UIを実装してみます。
このタイプのUIは既存の2Dスクリーンでもよく見られるボタンやスライダーなどの平面型GUIを操作するのに便利なため、VIVEのホーム画面などでも採用されています。

---
### 新規シーンの構築

新規シーンを作成したら、まずは前章の通りSteamVR Pluginをインポートして、[CameraRig]プレハブを配置後、MainCameraを削除します。

---
### ステージの作成

まずは床を作ります。シーンに適当な大きさで3D Object/Planeを追加してください。

次にレーザーコントローラーの操作対象となるオブジェクトを作成します。
今回はUnity4.6から追加された標準のGUIセットであるuGUIの各GUIパーツをレーザーで操作できるようにします。
まずUI/Canvasオブジェクトを作成し、その子に各種GUIを追加していきます。

![image][1073979559]

またこの際、Canvasの座標系はWorld Spaceに設定してください。

![image][1073979558]

---
### LaserController.csの作成  

次にレーザーの見た目を表現するスクリプトを作成します。
Projectパネル内にLaserControllerという名前でC#Scriptを作成し、Hierarchyパネル上の[CameraRig]/Controller (right/left)にアタッチします。

レーザーポインタの見た目は、プリミティブなCubeとSphereをスクリプトから動的に作成して表現することにします。
このスクリプトはVIVEコントローラーを表現するオブジェクトにアタッチしているので、this.transformの原点はVIVEコントローラの先端の輪っか部分になります。
そこから細長いCubeを伸ばして、その先端にSphereを配置することでレーザーを表現します。

なおこの際、レーザー同士のコリジョンが起こることを防ぐため、各プリミティブにアタッチされているColliderは削除しておきます。

```
GameObject laser;
GameObject cursor;

public float thickness = 0.002f;
public float cursorSize = 0.04f;
public Color laserColor = new Color( 1, 1, 0 );

void Start() {

  //レーザーポインタを表現するオブジェクトを作成する
  laser = GameObject.CreatePrimitive(PrimitiveType.Cube);
  laser.transform.SetParent(transform, false);
  laser.transform.localScale = new Vector3( thickness, thickness, 2.0f );
  laser.transform.localPosition = new Vector3(0.0f, 0.0f, 1.0f);
  laser.GetComponent<MeshRenderer>().material.color = laserColor;
  Object.DestroyImmediate(laser.GetComponent<BoxCollider>());

  cursor = GameObject.CreatePrimitive(PrimitiveType.Sphere);
  cursor.transform.SetParent(transform, false);
  cursor.transform.localScale = new Vector3( cursorSize, cursorSize, cursorSize );
  cursor.transform.localPosition = new Vector3(0.0f, 0.0f, 2.0f);
  cursor.GetComponent<MeshRenderer>().material.color = laserColor;
  Object.DestroyImmediate(cursor.GetComponent<SphereCollider>());
}
```

次にこのレーザーの長さを動的に変更するためのメソッドも実装しておきましょう。

```
public void AdjustLaserDistance ( float distance ) {

  if( laser == null ){ return; }
  distance += 0.01f;

  //レーザーの長さを調整
  laser.transform.localScale = new Vector3( thickness, thickness, distance );
  laser.transform.localPosition = new Vector3( 0.0f, 0.0f, distance * 0.5f );
  cursor.transform.localPosition = new Vector3( 0.0f, 0.0f, distance );
}
```

---
### LaserInputModule.csの作成  

次にレーザーポインタとオブジェクトのヒット判定を行うためのスクリプトを実装します。
しかし今回のレーザーの操作対象はuGUIパーツのため、前回使用したPhysics.RayCast()は使えません。
uGUIとのヒット判定を行うためには、Unityが提供するEventSystem/InputModuleコンポーネントを拡張し、独自のイベントシステムを実装する必要があります。

この実装の詳細は長くなるため、ここではサンプルシーン内に用意したLaserInputModule.csを直接使用することにします。
Hierarchyパネル上にUI/EventSystemオブジェクトを追加して、LaserInputModuleをアタッチしてください。
EventSystemにデフォルトでアタッチされているマウスやキーボード入力を処理するStandaloneInputModuleは必要がなければ無効にするか削除して構いません。

![image][1073979557]

以下にLaserInputModule内で行っている処理の簡単な解説をしておきます。実装の詳細はソースコードを直接参照してください。

まずBaseInputModuleクラスを継承し、標準のInputModuleが提供する入力システムをフックして、マウス入力をエミュレートします。
uGUIパーツとのヒットテストをEventSystem.RaycastAll()メソッドで行うために、レーザー専用のカメラを作成して各Canvasにセットします。

```
protected override void Start() {

    base.Start();

    // GUI-Raycast用のCameraを作成
    UICamera = new GameObject("UI Camera").AddComponent<Camera>();
    UICamera.fieldOfView = 5;
    UICamera.nearClipPlane = 0.01f;
    UICamera.stereoTargetEye = StereoTargetEyeMask.None;
    UICamera.clearFlags = CameraClearFlags.Nothing;
    UICamera.cullingMask = 0;

    // 全UIキャンバスにUICameraをセット
    Canvas[] canvases = UnityEngine.Resources.FindObjectsOfTypeAll<Canvas>();
    foreach ( Canvas canvas in canvases ) {
      canvas.worldCamera = UICamera;
    }

    ...
```

```
private bool GUIRaycast( int index ){

    if ( pointEvents[index] == null ) {
        pointEvents[index] = new PointerEventData(base.eventSystem);
    }else {
        pointEvents[index].Reset();
    }

    // UICameraのベクトルをレーザーと一致させる
    UICamera.transform.position = lasers[index].gameObject.transform.position;
    UICamera.transform.forward = lasers[index].gameObject.transform.forward;

    // UICameraの中心からUIキャンバスへレイキャスト
    pointEvents[index].delta = Vector2.zero;
    pointEvents[index].position = new Vector2( Screen.width / 2, Screen.height / 2 );
    pointEvents[index].scrollDelta = Vector2.zero;

    // ヒットテスト
    base.eventSystem.RaycastAll( pointEvents[index], m_RaycastResultCache );
    pointEvents[index].pointerCurrentRaycast = FindFirstRaycast( m_RaycastResultCache );
    m_RaycastResultCache.Clear();

    return pointEvents[index].pointerCurrentRaycast.gameObject != null;
}

```

あとは、Process()内で下記のように毎フレームごとに各Canvasへレイキャストし、ヒットするGUIパーツが見つかったら、クリックやドラッグイベントを発行します。

```
public override void Process() {

    // 全UIキャンバスとレーザーのヒットテスト
    for ( int index = 0; index < lasers.Length; index++ ) {

        // 現在選択中のUIの選択を解除
        ClearSelection();

        // レイキャスト & ヒットテストを行う
        bool hit = GUIRaycast( index );
        if ( hit == false ) {
          lasers[index].AdjustLaserDistance( 0 );
          continue;
        }

        // ヒットしたオブジェクトを保持
        hitObjects[index] = pointEvents[index].pointerCurrentRaycast.gameObject;
        base.HandlePointerExitAndEnter( pointEvents[index], hitObjects[index] );

        // レーザーの長さを調整
        if ( pointEvents[index].pointerCurrentRaycast.distance > 0.0f ) {
          lasers[index].AdjustLaserDistance( pointEvents[index].pointerCurrentRaycast.distance );
        }

  ...

```

---
### シーンの実行

シーンを実行すると、VIVEコントローラーの先端からレーザーが出力され、各種GUI上でトリガーを引くことでマウスと同じような操作が可能になっているかと思います。

![image][1073979554]

今回作成したCanvasはWorld Spaceでレンダリングされているので、このCanvasを[CameraRig]/Controller (right/left)の子に配置することで、
サンプルシーンのような常にVIVEコントローラーに追随するメニューパネルを実装することも可能です。

![image][1073979555]

** 今回のサンプルシーンの場所 **
- git:// VR-studies/Asset/VR-studies/2_VR-controller/2-2_LaserController
